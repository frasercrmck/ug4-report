\section{Inheritance}
\label{sec:inheritance}

Object-oriented programming languages revolve around the ability for one class to reuse the behavior and attributes of another by \textit{inheriting} the data from a base class, also known as a superclass. The translation of this concept to LLVM bytecode proves a challenge to the compiler writer, since LLVM has no notion of classes. The closest that LLVM comes to having class behaviour  in the object-oriented sense comes through the use of structs.

We have previously discussed the challenges that the difference in paradigms presents to us in the form of objects and structs (see Section \ref{sec:codegen}). The other, more difficult challenge to tackle is that of object inheritance. Inheritance is effectively achieved through the same paradigm a C programmer might use to accomplish the same goal. Listing \ref{lst:c_inh} highlights how inheritance is tackled in the C programming language.

\lstset{
	language=C,
	basicstyle=\small,
	stringstyle=\ttfamily
}

\begin{lstlisting}[frame=single, numbers=left, numberstyle=\tiny, caption={C Inheritance}, label=lst:c_inh]
typedef struct {
    // base members
} Base;

typedef struct {
    Base base;  
    // derived members   
} Derived;

...

Derived *d;
Base *b = (Base *)d;
\end{lstlisting}

\newpage

\begin{lstlisting}[frame=single, numbers=left, numberstyle=\tiny, caption={LLVM IR Inheritance}, label=lst:llvm_inh]
%Base = type { /* base members */ }
%Derived = type { %Base, /* derived members */ }

...

%0 = alloca %Derived
%1 = bitcast %Derived* %0 to %Base*
\end{lstlisting}

We can see at line 6 of the C code and at line 2 of the LLVM bytecode (Listings \ref{lst:c_inh} and \ref{lst:llvm_inh}, respectively), that each struct features as its first field an instance of the super class. This way it can be cast to this class at runtime, as we do at lines 13 and 7 of each respective code sample. The object can then be used as if it were an instance of the super class, giving it access to the necessary data.
