\section{Dalvik Executable Parsing}
\label{sec:parsing}

The first step in designing a compiler is naturally the parsing of the input language, which in our case is the Dalvik executable file format. On examining the file structure, we are able to see that the language is context-sensitive, according to the definition given by the Chomsky hierarchy of formal grammars. This is the case since each main section of data is located at a specific offset into the file, given in an initial header item. Furthermore, each section is broken down into subsections, all at offsets given elsewhere in the file. This means that we are unable to use the majority of parser generators for this section of the compilation process. These tools, which, given a formal definition of a language, generate the source code of a parser which can then be used as a component in the compiler toolchain. The drawback is that many of these are unable to handle context-sensitive languages.

% Code generator that can handle context-sensitive grammars?

It is therefore simpler that we design a custom parser for the Dalvik format which takes a Dalvik executable file as input and constructs an internal representation that we can pass on to the later components of the compiler. Hence, a custom parser is written in C++. The reason for using C++ is that we will be interfacing with the LLVM C++ API for generating code further down the line. The job of the parser is twofold: it traverses the input file in order, both keeping track of the various data sections it comes across for later use, and validating that the file is a valid Dalvik executable file.

As is evident from the structure presented in Table \ref{tab:dalvik_layout}, the file format is impossible to define in a context-free sense, given the self-referential nature of the format. This layout, however, renders it relatively straightforward to parse. It is a matter of traversing the input in accordance with the file structure as documented online \cite{dvk_format}, and keeping a track of the various data structures encountered along the way.

While most compilers must check that the source program adheres to the syntax of the language, we are able to skip a lot of this validation. Since the Dalvik executable format is itself compiled from a dialect of Java, we could assume that it is syntactically and semantically correct. However, this leaves us open to violations by hacking the Dalvik file after it has been translated from the Java .class files. Nevertheless, the rigidly structured nature of the Dalvik executable format (Table \ref{tab:dalvik_layout}) means that a lot of the syntactic checking is done for us in the structure of the file.

Some details of the Dalvik file are left out for the purposes of this compiler. The debug information stored about each method's code item is ignored, as it serves no purpose in the translation to LLVM intermediate representation. Likewise, the annotation information for each class definition is deemed as unnecessary. Debug and annotation data may serve a purpose in future work, as information gleaned from them could prove useful in certain language-specific optimisations.
